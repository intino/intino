	{
	parserClass='io.intino.plugin.lang.parser.TaraParser'
	parserUtilClass="io.intino.plugin.lang.parser.TaraParserUtil"
	psiVisitorName="TaraVisitor"
	extends='com.intellij.extapi.psi.ASTWrapperPsiElement'
	implements='io.intino.plugin.lang.psi.TaraPsiElement'
	psiClassPrefix='Tara'
	psiImplClassSuffix='Impl'
	psiPackage='io.intino.plugin.lang.psi'
	psiImplPackage='io.intino.plugin.lang.psi.impl'

	elementTypeHolderClass='io.intino.plugin.lang.psi.TaraTypes'
	elementTypeClass='io.intino.plugin.lang.psi.TaraElementType'
	tokenTypeClass='io.intino.plugin.lang.psi.TaraTokenType'

	psiImplUtilClass='io.intino.plugin.lang.psi.impl.TaraPsiUtil'
}

root ::=COMMENT? NEWLINE* (dslDeclaration NEWLINE+)? imports? (mogram NEWLINE+)*

dslDeclaration ::= DSL headerReference

imports ::= (anImport NEWLINE*)+

anImport ::= USE headerReference NEWLINE {
	mixin= 'io.intino.plugin.lang.psi.impl.ImportMixin'
    implements='io.intino.plugin.lang.psi.Import'
}

doc ::= (DOC_LINE NEWLINE?)+ {
	mixin= 'io.intino.plugin.lang.psi.impl.DocMixin'
	implements='io.intino.plugin.lang.psi.Doc'
}

mogram ::= doc? signature body? {
	pin = 2
	mixin= 'io.intino.plugin.lang.psi.impl.MogramMixin'
	implements='io.intino.plugin.lang.psi.TaraPsiElement, io.intino.tara.model.Mogram, com.intellij.openapi.util.Iconable, com.intellij.pom.Navigatable'
}

signature::= (subOrFacetMogram | (metaIdentifier ruleContainer* parameters? identifier? facets? parent?)) (constraint? annotations?)  {
	pin = 1
	mixin= 'io.intino.plugin.lang.psi.impl.SignatureMixin'
	implements='io.intino.plugin.lang.psi.Signature'
}

private subOrFacetMogram ::= (SUB | FACET) ruleContainer* parameters? identifier facets?
{pin = 1}

private parent ::= EXTENDS identifierReference
{pin = 1}

parameters ::= LEFT_PARENTHESIS (parameter (COMMA parameter)*)? RIGHT_PARENTHESIS {
	pin = 1
	mixin = 'io.intino.plugin.lang.psi.impl.ParametersMixin'
	implements = 'io.intino.plugin.lang.psi.Parameters'
}

parameter ::= (identifier EQUALS)? value {
    pin = 2
	mixin = 'io.intino.plugin.lang.psi.impl.ParameterMixin'
	implements = 'io.intino.plugin.lang.psi.Valued, io.intino.tara.model.Parameter, com.intellij.pom.Navigatable'
}

facets ::= IS facetApply+
{pin = 1}

facetApply ::= metaIdentifier parameters? {
	mixin = 'io.intino.plugin.lang.psi.impl.FacetApplyMixin'
    implements = 'io.intino.plugin.lang.psi.TaraPsiElement, io.intino.tara.model.Facet, com.intellij.pom.Navigatable'
}

body ::= (NEW_LINE_INDENT NEWLINE? | INLINE) (parts NEWLINE+)+ DEDENT {
	pin = 1
	mixin = 'io.intino.plugin.lang.psi.impl.BodyMixin'
	implements = 'io.intino.plugin.lang.psi.Body'
}

private parts ::= propDescriptive | propertyPrescriptive | mogram | mogramReference

mogramReference ::= HAS ruleContainer* identifierReference annotations? {
	pin = 1
	mixin = 'io.intino.plugin.lang.psi.impl.MogramReferenceMixin'
	implements = 'io.intino.plugin.lang.psi.TaraPsiElement, io.intino.tara.model.Mogram, com.intellij.pom.Navigatable'
}

propertyPrescriptive ::= doc? DEF propType sizeRange? ruleContainer? identifier (EQUALS value)? flags? bodyValue? {
	pin = 2
	mixin = 'io.intino.plugin.lang.psi.impl.PropertyMixin'
	implements = 'io.intino.plugin.lang.psi.TaraPsiElement, io.intino.tara.model.Property, io.intino.plugin.lang.psi.Valued, com.intellij.openapi.util.Iconable, com.intellij.pom.Navigatable, com.intellij.psi.PsiNamedElement'
}
bodyValue ::= NEW_LINE_INDENT (stringValue | expression) NEWLINE? DEDENT {
	mixin = 'io.intino.plugin.lang.psi.impl.ValueMixin'
    implements = 'io.intino.plugin.lang.psi.TaraPsiElement, io.intino.plugin.lang.psi.Value'
}

propType::= FUNCTION_TYPE
                | INT_TYPE
                | LONG_TYPE
                | DOUBLE_TYPE
                | BOOLEAN_TYPE
                | STRING_TYPE
                | DATE_TYPE
                | INSTANT_TYPE
                | TIME_TYPE
                | WORD_TYPE
                | OBJECT_TYPE
                | RESOURCE_TYPE
                | identifierReference

sizeRange ::= LEFT_SQUARE size? RIGHT_SQUARE
size ::= NATURAL_VALUE_KEY | listRange

listRange ::= (NATURAL_VALUE_KEY | STAR) DOT DOT (NATURAL_VALUE_KEY | STAR)

ruleContainer ::= COLON rule
{pin=1}

rule ::= (LEFT_CURLY (identifier+ | ((range | stringValue) metric?) | metric) RIGHT_CURLY) | (identifierReference CLASS_TYPE?){
	mixin = 'io.intino.plugin.lang.psi.impl.RuleMixin'
	implements = 'io.intino.plugin.lang.psi.Rule, io.intino.plugin.lang.psi.TaraPsiElement'
}

range ::= (doubleValue | integerValue | STAR) (DOT DOT (doubleValue | integerValue | STAR))?

value ::= stringValue+
        | booleanValue+
        | tupleValue+
        | integerValue+ metric?
        | doubleValue+  metric?
        | expression+
        | emptyField
        | identifierReference+
        | methodReference+
{
	mixin = 'io.intino.plugin.lang.psi.impl.ValueMixin'
    implements = 'io.intino.plugin.lang.psi.Value, io.intino.plugin.lang.psi.TaraPsiElement'
}

methodReference ::= AT identifierReference
{pin = 1}

stringValue ::= (QUOTE_BEGIN CHARACTER* QUOTE_END) {
	mixin = 'io.intino.plugin.lang.psi.impl.StringMixin'
    implements = 'io.intino.plugin.lang.psi.StringValue, io.intino.plugin.lang.psi.TaraPsiElement'
}

expression  ::= (EXPRESSION_BEGIN CHARACTER* EXPRESSION_END) {
	mixin = 'io.intino.plugin.lang.psi.impl.ExpressionMixin'
    implements = 'io.intino.plugin.lang.psi.Expression, io.intino.plugin.lang.psi.TaraPsiElement'
}

booleanValue    ::= BOOLEAN_VALUE_KEY
tupleValue      ::= stringValue COLON doubleValue
integerValue    ::= NATURAL_VALUE_KEY | NEGATIVE_VALUE_KEY
doubleValue     ::= NATURAL_VALUE_KEY | NEGATIVE_VALUE_KEY | DOUBLE_VALUE_KEY
metric          ::= identifier | METRIC_VALUE_KEY

constraint::= WITH identifierReference (COMMA identifierReference)*
{pin = 1}

annotations ::= IS flag+ {
	pin = 1
	mixin = 'io.intino.plugin.lang.psi.impl.AnnotationsMixin'
	implements = 'io.intino.plugin.lang.psi.Annotations'
}


flag ::= GENERALIZATION  | PRIVATE | REACTIVE | COMPONENT
	| FEATURE | FINAL | REQUIRED | DECORABLE {
	mixin = 'io.intino.plugin.lang.psi.impl.FlagMixin'
	implements = 'io.intino.plugin.lang.psi.Flag'
}


propDescriptive ::= identifier ((EQUALS value) | bodyValue) {
    pin = 2
	mixin = 'io.intino.plugin.lang.psi.impl.VarInitMixin'
	implements = 'io.intino.plugin.lang.psi.Valued, io.intino.tara.model.Parameter'
}

emptyField ::= EMPTY_REF

headerReference ::= hierarchy* identifier {
	pin = 2
	mixin = 'io.intino.plugin.lang.psi.impl.IdentifierReferenceMixin'
	implements = 'io.intino.plugin.lang.psi.HeaderReference'
}

identifierReference ::= hierarchy* identifier {
	pin = 2
	mixin = 'io.intino.plugin.lang.psi.impl.IdentifierReferenceMixin'
	implements = 'io.intino.plugin.lang.psi.IdentifierReference'
}

private hierarchy ::= identifier (DOT | PLUS)
{pin = 2}

identifier ::=  IDENTIFIER_KEY {
	mixin = 'io.intino.plugin.lang.psi.impl.IdentifierMixin'
	implements = 'io.intino.plugin.lang.psi.Identifier'
}

metaIdentifier ::= METAIDENTIFIER_KEY | IDENTIFIER_KEY {
	mixin = 'io.intino.plugin.lang.psi.impl.MetaIdentifierMixin'
	implements = 'io.intino.plugin.lang.psi.MetaIdentifier'
}
